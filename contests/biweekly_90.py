from collections import Counter
#q3
def destroyTargets(nums, space):
    # m = max(nums)
    # numc = Counter(nums)
    
    # def check(seed):
    #     res=0
    #     for c in range(0,m//10000+1):
    #         if seed+c*space in numc:
    #             res+=numc[seed+c*space]
    #     return res
    
    # nums.sort(reverse=True)
    # mx = 0
    # res=0
    # for num in nums:
    #     t = check(num)
    #     if  t >= mx:
    #         mx = t
    #         res = num
    #     print(num)
    # return res
    ### actual solution
    # If you wonder why modulus/reminder:
    # - When adding c*space to a fix number, all of the number generated from this will be having same reminder. 
    """
    explanation:
        - When adding c*space to a fix number, all of the number generated from this will be having same reminder
        - we want the min number that gives us the (max targets from num+c*space)
        - therefore, nums with same remainder means they can be generated by (themself + c*space) 
        (2,4,6,8) space = 2, 1 group of 4 (rem=0)
        (1,3,5,7) space =2,  1 group of 4 (rem=1)
        (1,2,3,4) space=2 2 groups of 2 (rem-0,1)
        Therefore we are trying to find the group with most members. (in the same series themself+c*space) == (have same themself % space)
        then return min num in that group
    """
    mx = 0
    mp = Counter()
    for num in nums:
        mod = num%space
        mp[mod]+=1
        mx = max(mx,mp[mod])
    res = float("inf")
    for n in nums:
        if mx==mp[n%space]:
            res = min(res,n)
    return res
nums = [625879766,235326233,250224393,501422042,683823101,948619719,680305710,733191937,182186779,353350082]
space=4
x = destroyTargets(nums, space)
print(x)
